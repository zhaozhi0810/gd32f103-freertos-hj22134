一. 初步版本的建立。（2022-09-05）
1. freertos  来自FreeRTOSv202012.04-LTS.zip解压
2. portable 选择ARM_CM3
3. MemMang 选择heap_4.c
4.FreeRTOSConfig.h 来自网络代码的拷贝。注意该文件中的内容。
5.因为本单片机无外部晶振，所以需要设置选择内部晶振的方式。
6.移植一个led的闪烁实验，已经成功运行。（PB4正好与调试接口有关联，需要关闭部分调试接口）




二、做了串口的移植（2022-09-09）
1。出现了两个问题，一个是串口移植总是卡死，二是增加一个任务在vTaskStartScheduler函数中报错（其实手动只创建了两个任务）
2.串口卡死的问题是因为在中断函数中进入了临界代码函数，导致卡死，不能退出（uart_debug_handle.c中有详细描述）
3.第二个问题，需要修改栈的大小configTOTAL_HEAP_SIZE ，我改为了10k。
4.现在两个问题都已经解决，串口还只有基本功能。
5.倒是有个担心，每个任务消耗的内存都不少啊，任务太多，可能内存都不够用了！！！


三、模拟iic的移植
1. 考虑iic的时序是否不能打断，则考虑每一次iic通信能否进入临界段。设置临界段后，出现一个问题，模拟iic中有延时函数，这时是应该切换任务还是继续等待
2.进入临界段（关中断taskENTER_CRITICAL()、taskEXIT_CRITICAL()），能否调用vTaskDelay，即这个函数能否正确延时并返回呢？实验证明不行！！！！直接卡死
为啥我要禁止中断呢？因为键盘会触发外部中断。
3.改禁止任务调度的方式试试，vTaskSuspendAll()，xTaskResumeAll()，能否调用vTaskDelay，即这个函数能否正确延时并返回呢？实验证明不行！！！！直接卡死
4.最后只能把之前用的裸机的延时函数（Delay1us）重新移植过来了。因为模拟iic是一个us的延时，而freertos最小是ms，而且不能禁止任务切换。
5.由于systick的初始化在vTaskStartScheduler函数中，而我在初始化串口的时候就需要用到systick的定时器，所以。。。要么把初始化改到任务函数的while1前面。。4
6.改变思路，任务有关的初始化应该放在任务的函数中！！其他无任务的初始化函数可以安排在main函数中。测试正常了。
7.任务使用（裸机时的）全局变量的方式，不利于任务的休眠，改为其他方法：比如信号量等。任务在等待信号量时阻塞休眠。
8.修改为任务通知的方式，测试暂无问题。注意中断的优先级！！！

四、想合并串口的接收和发送到一个任务中。
1.使用了任务通知的方法，但是问题是，每次通知只能对一个字符有效。通知是设置某个位。
2.解决办法，xStreamBufferBytesAvailable读出缓存的数据个数，然后使用for循环处理数据。
3.有一个问题，在串口输入的处理中，有一个打印帮助信息，由于缓存比较小，导致当执行打印帮助信息时，串口部分卡死。解决办法，把streambuff扩大到512
4.这里还有一个问题，连续输入打印，让串口打印帮助信息，导致缓存被用完卡死。xStreamBufferSend 写入发送缓存时不等待，可以解决卡死的问题。
5.合并带来的麻烦就是接收的时候不能打印，会导致打印的数据堆积起来。
6.感觉还是拆开会不会好一点？
7.改为发送中断模式，这样也能节省一个任务。发送缓存必须大一点，不然打印的内容只有一部分。
8.xStreamBufferSend(_uart_tx_StreamBuffer_Handle,&c,1,x10ms); 把等待时间改为10ms，好像可以使缓存小一点，目前调到64字节没啥问题。（32和16卡死）



五、串口通信（与cpu之间）的移植
1.初始化和接收任务、发送中断可以参考调试串口，但是通信协议的解析这里需要重新考虑一下。
2.与cpu通信的串口，使用了接收中断，空闲中断，发送空中断。发送数据的时候使能发送空中断，查询到缓存没有数据的时候，关闭发送空中断。
3.接收时，直接存入缓存。空闲中断时，发出任务唤醒。
4.接收处理任务。被空闲中断唤醒。处理接收到的数据。
5.开始的时候出现超时问题，调整优先级后处理正常了。优先级已调整到最高了（4）。



六、移植lt9211时（gd32f103vbt6内存只有20k，比较吃紧）
1. iic通信再次卡死，configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );  task.c
2.已经调整任务栈的最小值，本来是130*4=520字节，改为64，即256字节
3.iic的不允许任务切换还是会带来卡死的问题。主要还是因为iic通信的时候，出现错误，然后出错的时候，又要调用printf函数，而此时正好又不允许任务调度，则出现一些互锁的问题。
改进：把允许任务切换放到出错的第一句。即允许任务切换后，再去做出错处理。


七、调试的时候发现调试串口不能正常解析命令了
1.可以打印出调试信息，但是按键盘没有任何输出，使用调试模式，可以追到有中断，但是任务那里就没有执行。原因未知
2.调试串口的时候，出现HardFault_Handler(void)的出错，停在这里面了。任务的缓存太小，改为512字节就正常了，
但是如果只修改串口的缓存未512，其他256，就还是不能响应串口的输入。
这里可能的问题是printf这个库函数需要的栈变量比较多，凡是使用printf的任务，对栈的要求就会增加导致的，稍后尽量减少printf的使用，看能否把栈的空间进一步缩小


八、去掉printf的函数后，任务栈可以到64字节了。
1.任务运行正常，
2.如果要打印数值的话，自己实现也需要增加栈的空间，才能不让串口接收正常，否则出现串口接收无响应现象。

九、找到一个原因
1. 3399在运行test程序，并且看门狗没有关闭。此时单片机的程序重新烧写，单片机重启。
2.3399（人为）退出test程序，它默认会关闭看门狗。此时单片机端会删除看门狗的任务，但是此时看门狗的任务句柄为空（NULL），调用任务删除时，实际把与cpu通信的任务删除。
因为是cpu通信的任务调用的，相当于删除任务函数的参数是NULL，此时正好是删除任务本身。
3.导致3399再次运行test，无法启动，每次都是超时错误。查看任务的时候，发现原来tocpu的任务已经不存在了，所以就不会再应答了。

十、加入了任务信息
1.通过任务信息，比较方便去定位问题，而且可以监控栈是否够用的问题！！！适当的调整了某些任务的栈大小。
2.不能再调用printf函数，会导致卡死（因为栈比较小）。


2022-09-16 
1. 增加timer1 对LED键灯PWM的控制，频率50HZ，PWM实际分为20等级，0-20，20对应PWM为100.
2. 对键灯的状态记录部分，修复bug，之前是以为只有32个灯，使用了uint32，后来已经改为40个，所以变量类型改为uint64，并修复一些位操作。
3.对键灯部分进行了控制测试。
4.音频输出音量加，减，声音关闭，声音开启控制测试正常
5.屏幕开关测试正常。（实际是关闭pwm）
6.cpu温度和板卡温度读取正常。（板卡温度不一定准！！！）
7.设置键灯pwm正常（示波器查看波形）。
8.获得键灯的状态测试正常。
9.开启，关闭某一个或者全部键灯正常。
10.获得lcd的类型正常。
11.获得键盘类型正常。
12.rtc获取正常，，rtc设置正常。
13.看门狗操作正常。（开启，关闭，设置超时时间，获得超时时间，喂狗）
14.lcd屏复位（目前是lt9211复位）正常，核心板复位正常。
15.MIC_CRL引脚与PTT引脚联动正常


2022-09-21
1.对7寸屏的显示进行了适配，现在能够显示正常，能够调整7寸的亮度值。
2.该程序对于5寸显示屏不能正常显示！！！需要注意，后期需要加入对屏类型的识别，分别初始化9211
3.7寸屏幕的亮度调整由单片机控制屏幕的电流芯片（u38，x10s）完成。


2022-09-26
1. 修改iic_app的临界段方式，之前是禁止任务切换，现在改为禁止中断。简单的测试一下，好像没有什么问题。
因为iic是模拟信号，不知道能否被中断打断，如果被中断打断的代价是按键不能正常识别。
但是禁止中断的代价，会使系统的实时性降低，iic本身通信是需要时间的。
这个要平衡一下，到底是降低实时性呢，还是iic时序打断的风险！！概率应该都不是很大。



2022-12-12 升级硬件平台v1.3版本
1. cpu关机的串口指令，进行了修改。cpu端需要重新配置了reboot指令
2.增加键灯闪烁控制部分。完善控制接口，调试正常。
3.增加（PD5）io（LPSK）引脚初始化，默认高电平，PD5改为了PA7
4. 去除MicCtl_Control_Init引脚的功能
5.增加LcdType_Control_Init(void) 对应PC8，9，10的函数功能
6. 完善Get_Lcd_Type(void)函数的实现，增加串口获取屏幕类型接口
7.增加V12_CTRL（PC6）引脚初始化，默认低电平
8.修改键灯闪烁控制任务，适配freertos，改为定时器（timer1）的方式。
9.修改键灯亮度控制为PWM方式。
10. 按键外部中断有点异常。exti_interrupt_flag_get读取中断的时候为0，但是实际中断标志被置1。导致某些情况中断无法退出。
把清中断语句放到if的外面，程序正常了。导致故障原因未知，1.0的开发板没有这个现象。
11.基本能够使用，还需要大量测试。


2022-12-13  v1.3
1.完成LPSK，MicCtl，V12_CTRL API端口的测试
2.增加5寸屏的背光使能控制，对api中屏幕开启关闭进行了控制测试，正常。
3.屏幕类型api测试正常。
4.键灯亮度可调，正常。
5.新版硬件升级到了V1.4，LPSK引脚重新改回PD5引脚！！！！



2022-12-16  v1.3
1.V12_CTRL 上电开机后一直输出高。（之前是低）



2022-12-17  v1.3
1.morse_ptt 控制，增加了morse控制任务和中断初始化函数。
2.取消16号，V12_CTRL 上电开机后一直输出高。（改为输出低）



2022-12-19  v1.4
1.完善了一条单片机重启的指令，用于开发板重启时，单片机重启
	利用看门狗的定时复位功能，延时约3s
2.LPSK，改为PD5.1.3的板子继电器不受控制了。



2022-12-20  v1.4
1.修复与3399串口通信的一个重大bug，持续多线程通信测试时，出现单片机不再应答的现象。
  单片机接收的处理出现bug，已经修复，目前测试正常，故障不再复现。
2.单片机重启功能逻辑已重新调整，由uboot发送串口指令，重启单片机。之前做的重新制作rk3399的重启命令已经不再使用，
   单片机的处理流程已经发生改变。
3.根据测试，键灯的控制，在cs引脚产生边沿信号即可，不管是上升沿还是下降沿。中间间隔30us及以上。
  键灯的状态不能读取，因为D引脚设置为输入时，使用cs边沿信号后会使对方认为我在输出高电平，导致led全部点亮。



2023-01-11
1.客户调试时发现单独点亮某个灯，亮度正常。一个一个全部点亮，亮度也是正常的。
  但是使用全部点亮的命令（编号40），就亮度很暗。
  目前程序修改，全部点亮的时候是从单片机端一个一个去点亮的。


2023-01-13
1.继电器原默认开启，改为默认关闭。


2023-01-14
1.由于控制键灯亮度的时候不平滑，单片机串口的通信改为不应答，除非需要返回数据


2023-01-15
1.增加版本信息1.01，cpu串口，调试串口均可查看。
2.启动不再点亮、熄灭全部的键灯



2023-02-02
1. 增加串口升级的方法。调试串口命令y
2. 需要OTA程序的支持。

2023-02-03
1. 可以使用OTA串口的方式升级了，添加了脚本，自动生成bin文件，串口下载使用ymodem，传输bin文件
2.OTA程序在flash的头部位置，经验证，本程序可以使用keil下载和在线调试功能。
3.如果批量升级的话，建议合并ota和本程序的bin文件。最终下载合并文件。
4.OTA程序大小10K（从0x8000000开始）左右，本程序设置在偏移地址12K的位置。一定要注意OTA程序大bin文件大小，然后调整偏移值。


2023-02-10   v102
1.版本升级到1.02
2.解决test+9 组合键不能识别的问题，包括先后按下组合键和同时按下组合键的识别问题。
3.按键信息通过调试串口打印受到控制，调试串口按p可以开启打印和关闭打印。
4.三个组合键，有一个在焦点时，会识别为4个按键，是个bug，不解决了。


2023-03-29   v102
1.版本不变，系统没有修改
2.发现有息屏的功能。解决reboot时白屏现象，并且白屏中还会出现黑线条的问题。
3.需要修改3399系统的reboot命令，在reboot的时候，应该先发送息屏命令到单片机，然后系统本身再重启。


2023-04-12   v103
1.考虑从rk3399升级单片机程序的方法，单片机是串口1（PA2，3），rk3399是串口0（ttyS0）
2.rk3399的程序，请参考库https://github.com/zhaozhi0810/mcu_update_uart_ymodem
3.目前不是很稳定，还在进一步改善。
4.流程：rk3399发送升级命令，单片机关闭看门狗，重启，进入iap程序，
5.iap程序参考库：https://github.com/zhaozhi0810/gd32f103-OTA-uart


2023-04-12-2   v103
1.分成三个区，0~0x6000-1（OTA+flag，共24K），0x6000~0x13000-1（APP区，共52K），0x13000~0x20000-1（back区，共52K）
2.rk3399串口下载时，先下载到back区，下载成功后，更新到app区。 目前该功能已经完成。
3.两个标志，need_update：0xffff是需要升级(把down分区更新到app分区，同时表示升级不成功)，0x00ff表示升级成功
	   need_download：//需要升级吗？0xffff是不需要下载(同时表示下载成功)，0x00ff表示需要下载，
4.app程序收到升级信号时，修改need_download为0xff，让单片机重启后，OTA检查到该标志，就进行串口升级操作。
5.需要改善的就是能否在这个程序判断md5是否一致，一致则不升级，否则进入升级。



